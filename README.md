# Домашнее задание к занятию "3.2. Работа в терминале, лекция 2"

1. Команда `cd` является встроенной в shell (shell builtin).  
   Не может быть внешней, т.к. внешняя команда (дочерний процесс) не может изменять окружение вызывающей ее оболочки (родительский процесс), а изменение рабочей директории представляет собой изменение его окружения.
   Также встроенная команда может вызываться как `builtin cd`, что оставляет ее доступной даже в случае, если она была переопределена (например с помощью alias).  
<br/><br/>
2. Для подсчета количества строк, в которых найдено искомое слово/строка достаточно использовать флаг -c (--count):  
   ```bash
   grep -c <some_string> <some_file>
   ```  
<br/><br/>
3. PID 1 соответствует процессу **systemd**  
   (`top` / `pstree -p` / `ps -p 1`)
<br/><br/>
4. Сперва требуетя понять на какое устройство мы хотим выполнить перенаправление.  
   Выполнив **w** в терминале получим список открытых PTS. Альтернативно можно выполнить `tty` в терминале, на который хотим осуществить перенаправление. 
   После этого: 
   ```bash
   ls 2>/dev/pts/X
   ```
   если требуется перенаправить исключительно stderr. 
   Либо 
   ```bash
   ls &>/dev/pts/X
   ```
   чтобы перенаправить оба stdout и stderr (не поддерживается в sh)
<br/><br/>
5. Используем простой скрипт basic_script.sh со следующим содержимым:
   ```bash
   #!/bin/bash
   read a
   read b
   num=$((a+b))
   echo $num
   ```
   и файл с входными данными **input**:
   ```
   3
   5
   ```
   Далее передадим файл **input** на stdin нашего скрипта и выведем полученный результат в файл **result**:
   ```bash
   ./basic_script.sh < input >result
   ```  
   Или такой, весьма бесполезный, пример :)
   ```bash
   cat < input >result
   ```  
<br/><br/>
6. Если предварительно не переключиться на другой tty и не выполнить в нем логин, то при попытке перенаправления на него получим:
   ```
   bash: /bin/tty3: Permission denied
   ```
   Если предварительно выполнить login на каком-либо другом TTY (например 3,ctrl + alt + 3),а затем вернуться обратно в PTY в графическом режиме, то перенаправления успешно сработает:
   ```bash
   echo hello > /dev/tty3
   ```   
   Переключившись в TTY3 увидим наше сообщение.
<br/><br/>
7. Выполнив `bash 5>&1` мы перенаправляем поток файла с дескриптором 5 нашего процеса _bash_ в поток stdout, первоначально его создав/открыв.  
   При выполнении `echo netology > /proc/$$/fd/5` мы перенаправляем его в файловый дескриптор 5, который в свою очередь перенаправляется в stdout и выводится на нашем экране.    
   Немного поиграв с таким перенаправлением, создал новый дескриптор 6, который перенавляется в файл _errors_. И далее в FD6 можно перенаправить stderr, который будет записываться в файл:
   ```bash
   bash 6>errors
   ls /this_directory_doesnt_exist 2>&6
   cat errors
   
   ls: cannot access '/this_directory_doesnt_exist': No such file or directory
   ```
<br/><br/>
8. Используя промежуточный дескриптор из предыдущего задания **bash 5>&1**, мы можем сохранить вывод stdout в pty, при этом перенаправив stderr в |
   ```bash
   ls existing_file not_existing_file 2>&1 1>&5 | grep cannot
   ```
   _existing_file_  
   _ls: <span style="color:red">cannot</span> access 'not_existing_file': No such file or directory_  
   Сперва мы перенаправляем stderr в stdout на текущий момент, а затем перенаправляем stdout в файл с дескриптором 5.   
   Как итог мы видим вывод в pty с успешно найденным файлом, а ошибка поиска второго файла передана в **grep**.  
   Можно сделать такое же перенаправление без предварительного использования `bash 5>&1`  
   ```bash
   ls existing_file not_existing_file 5>&1 1>&2 2>&5 | grep run
   ```
<br/><br/>
9. `cat /proc/$$/environ` покажет переменные окружения текущего процесса shell. Можно добиться того же результата, но в еще более читаемом виде вызвав `env`. 
<br/><br/>
10. `/proc/<PID>/cmdline` это файл, содержащий полную информацию о процессе из командной строки. Доступен только для чтения. Если процесс является зомби-процессом, то файл будет пустым.  
    `/proc/<PID>/exe` это симлинк на фактически выполняющуюся программу.  
<br/><br/>
11. ```bash
    cat /proc/cpuinfo | grep sse
    ```
    Судя по всему, старшей будет считаться **sse4а**, присущая процессорам AMD. **sse4_2** также поддерживается.  
<br/><br/>
12. По умолчанию при подключениии к удаленному устройству по ssh ему не выделяется TTY (наша виртуалка). Однако при подключении по ssh с удаленного устройства на новое TTY запрашивается, но он не доступен.  
    Для форсированного выделения TTY можно использовать флаг `-t` при подключениее по ssh
<br/><br/>
13. Скажу честно, я лишь частично понимаю почему оно изначально не работало и как именно я это исправил :) Но в итоге удалось успешно выполнить `reptyr` в **screen**.  
    Полная последовательность действий будет описана в конце, сначала опишу трудности с которыми столкнулся:  

    ```bash
    # первая попытка жалуется на совпадение uid и направляет в ptrace_scope
    reptyr 1335
    
    Unable to attach to pid 1335: Operation not permitted  
    The kernel denied permission while attaching. If your uid matches  
    the target's, check the value of /proc/sys/kernel/yama/ptrace_scope.  
    For more information, see /etc/sysctl.d/10-ptrace.conf  

    # может быть sudo все исправит? Как минимум другая ошибка
    sudo reptyr 1335
    
    [-] Unable to open the tty in the child.
 
    # ошибка с ubable to open the tty показалсь уже знакомой. На просторах интернета найдено решение с флагом -T. 
    # Как итог оно просто виснет.
    sudo reptyr -T 1335
    ```  

    Нашел другое решение ошибки из самой первой попытки, связанной с uid в prace_scope - `echo 0 > /proc/sys/kernel/yama/ptrace_scope`. Оно один в один совпало с ошибкой в задании **14** и не выполняется.  
    Поэтому применяем полученные навыки и выполняем `echo 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope`. После этого полностью повторяю перемещение процесса с помощью **reptyr**. Успешно :)

    ```  
    top
    # Ctrl + Z и отправляем процесс в фон
    jobs -l
    # флаг -l выдает <PID>_
    disown <PID>
    screen -S 'reptyr-to'
    reptyr <PID>
    ```  
<br/><br/>
14. Как и описано в задании в `sudo echo string > /root/new_file` перенаправлением занимается процесс shell, который запущен без sudo. Sudo не осуществляет перенаправление, а применяется только для echo.  
    `tee`  читает stdin и записывает из него в файл и в stdout (именно поэтому при выполнении `echo string | sudo tee /root/new_file` мы видим вывод _string_ в консоль).  
    Т.к. `tee` является исполняемой командой, а не метасимволом, для него мы можем применить sudo. 

